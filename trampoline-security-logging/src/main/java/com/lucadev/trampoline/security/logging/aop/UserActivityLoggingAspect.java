package com.lucadev.trampoline.security.logging.aop;

import com.lucadev.trampoline.security.logging.ActivityLayer;
import com.lucadev.trampoline.security.logging.LogUserActivity;
import com.lucadev.trampoline.security.logging.UserActivity;
import com.lucadev.trampoline.security.logging.UserActivityInvocationDetails;
import com.lucadev.trampoline.security.logging.handler.UserActivityHandler;
import com.lucadev.trampoline.security.persistence.entity.User;
import com.lucadev.trampoline.service.time.TimeProvider;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.context.expression.MapAccessor;
import org.springframework.core.annotation.Order;
import org.springframework.expression.EvaluationException;
import org.springframework.expression.Expression;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.HashMap;
import java.util.Map;

/**
 * Spring AoP aspect to handle method invocations that have the {@link LogUserActivity} annotation.
 *
 * @author <a href="mailto:luca@camphuisen.com">Luca Camphuisen</a>
 * @since 3/9/19
 */
@Aspect
@Order(20)
public class UserActivityLoggingAspect {

	private final UserActivityHandler userActivityHandler;
	private final TimeProvider timeProvider;
	private final SpelExpressionParser expressionParser;

	public UserActivityLoggingAspect(UserActivityHandler userActivityHandler, TimeProvider timeProvider) {
		this.userActivityHandler = userActivityHandler;
		this.timeProvider = timeProvider;
		this.expressionParser = new SpelExpressionParser();
	}

	@Pointcut("@annotation(com.lucadev.trampoline.security.logging.LogUserActivity)")
	public void logUserActivityDefinition() {
	}

	@Around("logUserActivityDefinition()")
	public Object logUserActivity(ProceedingJoinPoint joinPoint) throws Throwable {
		MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
		Method method = methodSignature.getMethod();
		Object[] methodInvocationArguments = joinPoint.getArgs();
		Object returnObject = null;
		Throwable throwable = null;
		long invocationStart = timeProvider.unix();
		try {
			returnObject = joinPoint.proceed();
		} catch (Throwable t) {
			throwable = t;
		} finally {
			long invocationEnd = timeProvider.unix();
			UserActivity userActivity = mapUserActivity(method, methodInvocationArguments,
					returnObject, throwable, invocationStart, invocationEnd);

			userActivityHandler.handleUserActivity(userActivity);
		}

		//Handle exception generated by proxied method
		if (throwable != null) {
			throw throwable;
		}
		return returnObject;
	}

	private UserActivity mapUserActivity(Method method, Object[] methodInvocationArguments, Object returnObject,
										 Throwable throwable, long invocationStart, long invocationEnd) {
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();


		String className = method.getDeclaringClass().getName();


		LogUserActivity logUserActivity = method.getAnnotation(LogUserActivity.class);
		String logIdentifier = logUserActivity.value();
		String category = logUserActivity.category();
		String logDescription = logUserActivity.description();
		boolean spelDescription = logUserActivity.spelDescription();
		ActivityLayer activityLayer = logUserActivity.layer();
		String description = logDescription;

		//Parse SPeL expression
		if (spelDescription) {
			Expression expression = expressionParser.parseExpression(description);
			Map<String, Object> argsMap = createArgsMap(methodInvocationArguments, method);
			argsMap.put("returnObject", returnObject);
			StandardEvaluationContext evaluationContext = new StandardEvaluationContext(argsMap);
			evaluationContext.addPropertyAccessor(new MapAccessor());
			try {
				description = expression.getValue(evaluationContext, String.class);
			} catch (EvaluationException ex) {
				throw ex;
			}
		}

		UserActivityInvocationDetails invocationDetails = new UserActivityInvocationDetails(
				className, method.getName(), throwable != null, invocationStart, invocationEnd
		);
		UserActivity userActivity = new UserActivity((User) authentication.getPrincipal(),
				logIdentifier, category, activityLayer, invocationDetails, description);

		return userActivity;
	}

	private Map<String, Object> createArgsMap(Object[] args, Method method) {
		Map<String, Object> argsMap = new HashMap<>();
		for (int i = 0; i < method.getParameters().length; i++) {
			Parameter parameter = method.getParameters()[i];
			argsMap.put(parameter.getName(), args[i]);
		}
		return argsMap;
	}

}
